#!/usr/bin/env bash

# exit on error
set -e

info() {
  tput setf 6 # yellow
  echo "> ${*}"
  tput sgr0
}

error() {
  tput setf 4 # red
  echo "> ${*}"
  tput sgr0
}

hook() {
  file="${script_dir}/${1}.sh"
  if [ -f "$file" ]; then
    info "Running script ${1}"
    source "$file"
  fi
}

# determine this script's location
this="$(which "${0}")"
whereami="$(cd "$( dirname "$(readlink "${this}" || echo "${this}")")"; pwd)"

cd "$whereami"

deploy_dir="${whereami}/deploy"
script_dir="${deploy_dir}/scripts"
nd_file="${deploy_dir}/next_deploy"
source "${deploy_dir}/config"

if [ ! -f "${nd_file}" ]; then
  echo "a" > "${nd_file}"
  info "WARNING: ${nd_file} did not exist, first deploy?"
fi

next_deploy="$(cat "${nd_file}")"
if [ -z "${next_deploy}" ]; then
  info "WARNING: ${nd_file} was empty"
  next_deploy="a"
fi

hook "begin"

start() {
  start_name="${1}"
  start_dir="${2}"
  port="${3}"
  hook "pre_start"

  info "Starting ${start_name}"
  env PORT="${port}" forever start --uid "${start_name}" -l "${log_forever}" -o "${start_dir}/${log_out}" -e "${start_dir}/${log_error}" --workingDir "${start_dir}" --sourceDir "${start_dir}" -p "${start_dir}" -a --minUptime 9000 --killSignal SIGTERM "${start_script}" > /dev/null

  hook "post_start"
}

stop() {
  stop_name="$1"
  hook "pre_stop"

  info "Shutting down ${stop_name} ..."
  if forever stop "${stop_name}" > /dev/null; then
    info "Stopped ${stop_name}."
  else
    info "Couldn't stop ${stop_name}. Maybe it was not running?"
  fi

  hook "post_stop"
}

is_running() {
  forever list --no-color | grep -v "STOPPED" | grep -q "${1}"
}

substitute() {
  deploy_app="${app}_${next_deploy}"

  if is_running "${deploy_app}"; then
    error "Looks like ${deploy_app} is already running"
    error "Please fix manually"
    return 1
  fi

  stop_char="a"
  port="3001"
  if [ "${next_deploy}" = "a" ]; then
    stop_char="b"
    port="3002"
  fi

  stop_app="${app}_${stop_char}"
  app_dir="${whereami}/${deploy_app}"

  if [  "${action}" = "deploy" ]; then
    pushd "${app_dir}/" > /dev/null
    commit="origin/master"
    if [ -n "${1}" ]; then
      commit="${1}"
    fi

    hook "pre_install"

    info "starting deploy for ${deploy_app}"
    tput setf 3
    git fetch --all
    info "git fetch completed"
    tput setf 3
    git reset --hard "${commit}"
    info "git checkout completed"

    tput setf 3
    npm install --production 2>&1 | grep "" # disable colors
    info "npm install completed"

    hook "post_install"

    popd > /dev/null
  fi
  start "${deploy_app}" "${app_dir}" "${port}"

  if [ "${action}" = "deploy" ]; then
    cleanup() {
      kill "${tail_pid}"
    }
    trap cleanup INT # run cleanup on ^C
    info "Showing log for 10 seconds"
    echo
    tail -n 0 -F "${app_dir}/logs/forever.log" &
    tail_pid="$!"
    sleep 10
    cleanup
  fi

  if is_running "${deploy_app}"; then
    tput setf 2; echo -e "\n> ${deploy_app} has been deployed on port ${port}.\n"; tput sgr0
  else
    error "${deploy_app} is no longer running, deploy failed"
    return 1
  fi

  stop "${stop_app}"
  info "Setting next_deploy to ${stop_app}"
  echo "${stop_char}" > "${nd_file}"

  tput setf 2; echo -e "\n> ${action} completed!\n"; tput sgr0
}

case "${1}" in
deploy)
  action="deploy"
  substitute "${2}";;
rollback)
  action="rollback"
  substitute;;
start)
  start "${2}" "${3}" "${4}";;
stop)
  stop "${2}";;
*)
  echo "Usage:"
  echo "  $0 deploy [COMMIT]"
  echo "  $0 rollback"
  echo "  $0 start <APP_NAME> <APP_DIR> <PORT>"
  echo "  $0 stop <APP_NAME>"
esac

hook "end"